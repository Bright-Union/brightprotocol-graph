// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BuyCoverEvent extends ethereum.Event {
  get params(): BuyCoverEvent__Params {
    return new BuyCoverEvent__Params(this);
  }
}

export class BuyCoverEvent__Params {
  _event: BuyCoverEvent;

  constructor(event: BuyCoverEvent) {
    this._event = event;
  }

  get _productAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _productId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _period(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get _asset(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get _amount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get _price(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class IDistributor__getCoverResultValue0Struct extends ethereum.Tuple {
  get coverType(): Bytes {
    return this[0].toBytes();
  }

  get productId(): BigInt {
    return this[1].toBigInt();
  }

  get contractName(): Bytes {
    return this[2].toBytes();
  }

  get coverAmount(): BigInt {
    return this[3].toBigInt();
  }

  get premium(): BigInt {
    return this[4].toBigInt();
  }

  get currency(): Address {
    return this[5].toAddress();
  }

  get contractAddress(): Address {
    return this[6].toAddress();
  }

  get expiration(): BigInt {
    return this[7].toBigInt();
  }

  get status(): BigInt {
    return this[8].toBigInt();
  }

  get refAddress(): Address {
    return this[9].toAddress();
  }
}

export class IDistributor__getQuoteResultValue0Struct extends ethereum.Tuple {
  get prop1(): BigInt {
    return this[0].toBigInt();
  }

  get prop2(): BigInt {
    return this[1].toBigInt();
  }

  get prop3(): BigInt {
    return this[2].toBigInt();
  }

  get prop4(): BigInt {
    return this[3].toBigInt();
  }

  get prop5(): BigInt {
    return this[4].toBigInt();
  }

  get prop6(): BigInt {
    return this[5].toBigInt();
  }

  get prop7(): BigInt {
    return this[6].toBigInt();
  }
}

export class IDistributor extends ethereum.SmartContract {
  static bind(address: Address): IDistributor {
    return new IDistributor("IDistributor", address);
  }

  getCover(
      _owner: Address,
      _coverId: BigInt,
      _isActive: boolean,
      _loopLimit: BigInt
  ): IDistributor__getCoverResultValue0Struct {
    let result = super.call(
        "getCover",
        "getCover(address,uint256,bool,uint256):((bytes32,uint256,bytes32,uint256,uint256,address,address,uint256,uint256,address))",
        [
          ethereum.Value.fromAddress(_owner),
          ethereum.Value.fromUnsignedBigInt(_coverId),
          ethereum.Value.fromBoolean(_isActive),
          ethereum.Value.fromUnsignedBigInt(_loopLimit)
        ]
    );

    return changetype<IDistributor__getCoverResultValue0Struct>(
        result[0].toTuple()
    );
  }

  try_getCover(
      _owner: Address,
      _coverId: BigInt,
      _isActive: boolean,
      _loopLimit: BigInt
  ): ethereum.CallResult<IDistributor__getCoverResultValue0Struct> {
    let result = super.tryCall(
        "getCover",
        "getCover(address,uint256,bool,uint256):((bytes32,uint256,bytes32,uint256,uint256,address,address,uint256,uint256,address))",
        [
          ethereum.Value.fromAddress(_owner),
          ethereum.Value.fromUnsignedBigInt(_coverId),
          ethereum.Value.fromBoolean(_isActive),
          ethereum.Value.fromUnsignedBigInt(_loopLimit)
        ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
        changetype<IDistributor__getCoverResultValue0Struct>(value[0].toTuple())
    );
  }

  getCoverCount(_userAddr: Address, _isActive: boolean): BigInt {
    let result = super.call(
        "getCoverCount",
        "getCoverCount(address,bool):(uint256)",
        [
          ethereum.Value.fromAddress(_userAddr),
          ethereum.Value.fromBoolean(_isActive)
        ]
    );

    return result[0].toBigInt();
  }

  try_getCoverCount(
      _userAddr: Address,
      _isActive: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
        "getCoverCount",
        "getCoverCount(address,bool):(uint256)",
        [
          ethereum.Value.fromAddress(_userAddr),
          ethereum.Value.fromBoolean(_isActive)
        ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getEaseCovers(
      _userAddr: Address,
      _vaultTokenAddrs: Array<Address>
  ): Array<BigInt> {
    let result = super.call(
        "getEaseCovers",
        "getEaseCovers(address,address[]):(uint256[])",
        [
          ethereum.Value.fromAddress(_userAddr),
          ethereum.Value.fromAddressArray(_vaultTokenAddrs)
        ]
    );

    return result[0].toBigIntArray();
  }

  try_getEaseCovers(
      _userAddr: Address,
      _vaultTokenAddrs: Array<Address>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
        "getEaseCovers",
        "getEaseCovers(address,address[]):(uint256[])",
        [
          ethereum.Value.fromAddress(_userAddr),
          ethereum.Value.fromAddressArray(_vaultTokenAddrs)
        ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  getQuote(
      _sumAssured: BigInt,
      _coverPeriod: BigInt,
      _contractAddress: Address,
      _coverAsset: Address,
      _nexusCoverable: Address,
      _data: Bytes
  ): IDistributor__getQuoteResultValue0Struct {
    let result = super.call(
        "getQuote",
        "getQuote(uint256,uint256,address,address,address,bytes):((uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
        [
          ethereum.Value.fromUnsignedBigInt(_sumAssured),
          ethereum.Value.fromUnsignedBigInt(_coverPeriod),
          ethereum.Value.fromAddress(_contractAddress),
          ethereum.Value.fromAddress(_coverAsset),
          ethereum.Value.fromAddress(_nexusCoverable),
          ethereum.Value.fromBytes(_data)
        ]
    );

    return changetype<IDistributor__getQuoteResultValue0Struct>(
        result[0].toTuple()
    );
  }

  try_getQuote(
      _sumAssured: BigInt,
      _coverPeriod: BigInt,
      _contractAddress: Address,
      _coverAsset: Address,
      _nexusCoverable: Address,
      _data: Bytes
  ): ethereum.CallResult<IDistributor__getQuoteResultValue0Struct> {
    let result = super.tryCall(
        "getQuote",
        "getQuote(uint256,uint256,address,address,address,bytes):((uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
        [
          ethereum.Value.fromUnsignedBigInt(_sumAssured),
          ethereum.Value.fromUnsignedBigInt(_coverPeriod),
          ethereum.Value.fromAddress(_contractAddress),
          ethereum.Value.fromAddress(_coverAsset),
          ethereum.Value.fromAddress(_nexusCoverable),
          ethereum.Value.fromBytes(_data)
        ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
        changetype<IDistributor__getQuoteResultValue0Struct>(value[0].toTuple())
    );
  }

  isShieldedVault(_vault: Address): boolean {
    let result = super.call(
        "isShieldedVault",
        "isShieldedVault(address):(bool)",
        [ethereum.Value.fromAddress(_vault)]
    );

    return result[0].toBoolean();
  }

  try_isShieldedVault(_vault: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
        "isShieldedVault",
        "isShieldedVault(address):(bool)",
        [ethereum.Value.fromAddress(_vault)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isTokenMatchingVault(_token: Address, _vault: Address): boolean {
    let result = super.call(
        "isTokenMatchingVault",
        "isTokenMatchingVault(address,address):(bool)",
        [ethereum.Value.fromAddress(_token), ethereum.Value.fromAddress(_vault)]
    );

    return result[0].toBoolean();
  }

  try_isTokenMatchingVault(
      _token: Address,
      _vault: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
        "isTokenMatchingVault",
        "isTokenMatchingVault(address,address):(bool)",
        [ethereum.Value.fromAddress(_token), ethereum.Value.fromAddress(_vault)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
        "supportsInterface",
        "supportsInterface(bytes4):(bool)",
        [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
        "supportsInterface",
        "supportsInterface(bytes4):(bool)",
        [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class __EaseDistributor_initCall extends ethereum.Call {
  get inputs(): __EaseDistributor_initCall__Inputs {
    return new __EaseDistributor_initCall__Inputs(this);
  }

  get outputs(): __EaseDistributor_initCall__Outputs {
    return new __EaseDistributor_initCall__Outputs(this);
  }
}

export class __EaseDistributor_initCall__Inputs {
  _call: __EaseDistributor_initCall;

  constructor(call: __EaseDistributor_initCall) {
    this._call = call;
  }

  get _vaultController(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _brightProtocol(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class __EaseDistributor_initCall__Outputs {
  _call: __EaseDistributor_initCall;

  constructor(call: __EaseDistributor_initCall) {
    this._call = call;
  }
}

export class BuyCoverCall extends ethereum.Call {
  get inputs(): BuyCoverCall__Inputs {
    return new BuyCoverCall__Inputs(this);
  }

  get outputs(): BuyCoverCall__Outputs {
    return new BuyCoverCall__Outputs(this);
  }
}

export class BuyCoverCall__Inputs {
  _call: BuyCoverCall;

  constructor(call: BuyCoverCall) {
    this._call = call;
  }

  get _vault(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _user(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _uAmount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _expiry(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _v(): i32 {
    return this._call.inputValues[6].value.toI32();
  }

  get _r(): Bytes {
    return this._call.inputValues[7].value.toBytes();
  }

  get _s(): Bytes {
    return this._call.inputValues[8].value.toBytes();
  }

  get _newCumLiqForClaims(): BigInt {
    return this._call.inputValues[9].value.toBigInt();
  }

  get _liqForClaimsProof(): Array<Bytes> {
    return this._call.inputValues[10].value.toBytesArray();
  }
}

export class BuyCoverCall__Outputs {
  _call: BuyCoverCall;

  constructor(call: BuyCoverCall) {
    this._call = call;
  }
}

export class IsTokenMatchingVaultCall extends ethereum.Call {
  get inputs(): IsTokenMatchingVaultCall__Inputs {
    return new IsTokenMatchingVaultCall__Inputs(this);
  }

  get outputs(): IsTokenMatchingVaultCall__Outputs {
    return new IsTokenMatchingVaultCall__Outputs(this);
  }
}

export class IsTokenMatchingVaultCall__Inputs {
  _call: IsTokenMatchingVaultCall;

  constructor(call: IsTokenMatchingVaultCall) {
    this._call = call;
  }

  get _token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _vault(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class IsTokenMatchingVaultCall__Outputs {
  _call: IsTokenMatchingVaultCall;

  constructor(call: IsTokenMatchingVaultCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}
